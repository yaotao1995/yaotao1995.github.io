<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.6 -->
    <script>
        window.materialVersion = "1.5.6"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0',
            '1.5.2',
            '1.5.5'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">









    <link rel="dns-prefetch" href="https://fonts.googleapis.com"/>





    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            iOS笔记梳理 | 
        
        YaoTao&#39;sBlog
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">

    <meta name="format-detection" content="telephone=no"/>
    <meta name="description" itemprop="description" content="">
    <meta name="keywords" content="">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?NKhlKQkXw/c66TR5p4wO+w==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-image: url(/img/bg.png);
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Raleway:200,500,700,800" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="YaoTao&#39;sBlog">
    <meta name="msapplication-starturl" content="http://example.com/2019/10/30/%5BiOS%5D%E7%AC%94%E8%AE%B0/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="YaoTao&#39;sBlog">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://example.com/2019/10/30/%5BiOS%5D%E7%AC%94%E8%AE%B0/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="iOS笔记梳理 | YaoTao&#39;sBlog">
    <meta property="og:image" content="/img/favicon.png">
    <meta property="og:description" content="">
    

    
        <meta property="article:published_time" content="Wed Oct 30 2019 16:15:28 GMT+0800">
        <meta property="article:modified_time" content="Thu Mar 05 2020 10:51:36 GMT+0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://example.com/2019/10/30/%5BiOS%5D%E7%AC%94%E8%AE%B0/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://example.com/2019/10/30/%5BiOS%5D%E7%AC%94%E8%AE%B0/index.html",
    "headline": "iOS笔记梳理",
    "datePublished": "Wed Oct 30 2019 16:15:28 GMT+0800",
    "dateModified": "Thu Mar 05 2020 10:51:36 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "yaotao",
        "image": {
            "@type": "ImageObject",
            "url": "/img/avatar.png"
        },
        "description": "个人简介"
    },
    "publisher": {
        "@type": "Organization",
        "name": "YaoTao&#39;sBlog",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": "",
    "description": "",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

<meta name="generator" content="Hexo 5.4.2"></head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span id="MD-burger-id" class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#App%E5%90%AF%E5%8A%A8"><span class="post-toc-number">1.</span> <span class="post-toc-text">App启动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-%E6%9C%89storyboard"><span class="post-toc-number">1.0.0.1.</span> <span class="post-toc-text">1.有storyboard</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-%E6%97%A0storyboard"><span class="post-toc-number">1.0.0.2.</span> <span class="post-toc-text">2.无storyboard</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">启动流程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%89%8D"><span class="post-toc-number">1.0.1.1.</span> <span class="post-toc-text">1.main函数执行前</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-main%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%90%8E"><span class="post-toc-number">1.0.1.2.</span> <span class="post-toc-text">2.main函数执行后</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-%E9%A6%96%E5%B1%8F%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90%E5%90%8E"><span class="post-toc-number">1.0.1.3.</span> <span class="post-toc-text">3.首屏渲染完成后</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96"><span class="post-toc-number">1.0.2.</span> <span class="post-toc-text">启动优化</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6-Mach-o"><span class="post-toc-number">2.</span> <span class="post-toc-text">可执行文件(Mach-o)</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="post-toc-number">3.</span> <span class="post-toc-text">动态链接库</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Class%E5%8E%9F%E7%90%86"><span class="post-toc-number">4.</span> <span class="post-toc-text">Class原理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#KVO"><span class="post-toc-number">5.</span> <span class="post-toc-text">KVO</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#KVC"><span class="post-toc-number">6.</span> <span class="post-toc-text">KVC</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Category"><span class="post-toc-number">7.</span> <span class="post-toc-text">Category</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#AutoReleasePool"><span class="post-toc-number">8.</span> <span class="post-toc-text">AutoReleasePool</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#load%E6%96%B9%E6%B3%95"><span class="post-toc-number">9.</span> <span class="post-toc-text">+load方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#initialize%E6%96%B9%E6%B3%95"><span class="post-toc-number">10.</span> <span class="post-toc-text">+initialize方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="post-toc-number">11.</span> <span class="post-toc-text">符号表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ScrollView"><span class="post-toc-number">12.</span> <span class="post-toc-text">ScrollView</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#View%E3%80%81UIWindow%E3%80%81CALayer"><span class="post-toc-number">13.</span> <span class="post-toc-text">View、UIWindow、CALayer</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#frame-%E5%92%8C-bounds"><span class="post-toc-number">14.</span> <span class="post-toc-text">frame 和 bounds</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1ASSOCIATION"><span class="post-toc-number">15.</span> <span class="post-toc-text">关联对象ASSOCIATION</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Block"><span class="post-toc-number">16.</span> <span class="post-toc-text">Block</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Block%E6%8D%95%E8%8E%B7"><span class="post-toc-number">17.</span> <span class="post-toc-text">Block捕获</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="post-toc-number">17.0.1.</span> <span class="post-toc-text">局部变量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="post-toc-number">17.0.2.</span> <span class="post-toc-text">全局变量</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Block%E7%B1%BB%E5%9E%8B"><span class="post-toc-number">18.</span> <span class="post-toc-text">Block类型</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#block%E4%BF%AE%E9%A5%B0"><span class="post-toc-number">19.</span> <span class="post-toc-text">_block修饰</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Runtime"><span class="post-toc-number">20.</span> <span class="post-toc-text">Runtime</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Runloop"><span class="post-toc-number">21.</span> <span class="post-toc-text">Runloop</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="post-toc-number">21.0.1.</span> <span class="post-toc-text">执行流程</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="post-toc-number">22.</span> <span class="post-toc-text">多线程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#iOS%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%A1%88"><span class="post-toc-number">22.0.0.1.</span> <span class="post-toc-text">iOS中的多线程方案</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E6%9E%9C"><span class="post-toc-number">22.0.0.2.</span> <span class="post-toc-text">队列的执行效果</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%B8%80%E8%88%AC%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="post-toc-number">22.0.0.3.</span> <span class="post-toc-text">一般知识点</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#4%E4%B8%AA%E6%9C%AF%E8%AF%AD%E6%AF%94%E8%BE%83%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%EF%BC%9A%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E5%B9%B6%E5%8F%91%E3%80%81%E4%B8%B2%E8%A1%8C"><span class="post-toc-number">22.0.0.4.</span> <span class="post-toc-text">4个术语比较容易混淆：同步、异步、并发、串行</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#GNUstep"><span class="post-toc-number">22.0.0.5.</span> <span class="post-toc-text">GNUstep</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84-%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%AE%8C%E6%88%90%E4%B8%8D%E5%90%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%90%8C%E6%97%B6%E6%89%A7%E8%A1%8C%EF%BC%8C%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%AD%89"><span class="post-toc-number">22.0.0.6.</span> <span class="post-toc-text">线程组 - 可以在开发过程中完成不同任务的执行，同时执行，顺序执行等</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#OSSpinLock-%E8%87%AA%E6%97%8B%E9%94%81"><span class="post-toc-number">22.0.0.7.</span> <span class="post-toc-text">OSSpinLock 自旋锁</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#os-unfair-lock"><span class="post-toc-number">22.0.0.8.</span> <span class="post-toc-text">os_unfair_lock</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#pthread-mutex-%E4%BA%92%E6%96%A5%E9%94%81"><span class="post-toc-number">22.0.0.9.</span> <span class="post-toc-text">pthread_mutex - 互斥锁</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#NSConditionLock-%E6%9D%A1%E4%BB%B6%E9%94%81"><span class="post-toc-number">22.0.0.10.</span> <span class="post-toc-text">NSConditionLock - 条件锁</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="post-toc-number">22.0.0.11.</span> <span class="post-toc-text">Semaphore - 信号量</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%AF%B9%E6%AF%94%E5%87%A0%E4%B8%AA%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-number">22.0.0.12.</span> <span class="post-toc-text">对比几个锁的区别</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="post-toc-number">23.</span> <span class="post-toc-text">内存管理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#atomic"><span class="post-toc-number">23.0.1.</span> <span class="post-toc-text">atomic</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AF%BB%E5%86%99%E5%AE%89%E5%85%A8%EF%BC%8CIO%E6%93%8D%E4%BD%9C%E5%AE%89%E5%85%A8"><span class="post-toc-number">23.0.2.</span> <span class="post-toc-text">读写安全，IO操作安全</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#CADisplaylink-NSTimer"><span class="post-toc-number">23.0.3.</span> <span class="post-toc-text">CADisplaylink NSTimer</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#GCD%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="post-toc-number">23.0.4.</span> <span class="post-toc-text">GCD定时器</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="post-toc-number">23.0.5.</span> <span class="post-toc-text">内存分布</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Tagger-Pointer"><span class="post-toc-number">23.0.6.</span> <span class="post-toc-text">Tagger Pointer</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#MRC"><span class="post-toc-number">23.0.7.</span> <span class="post-toc-text">MRC</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Copy%E3%80%81MutableCopy"><span class="post-toc-number">23.0.8.</span> <span class="post-toc-text">Copy、MutableCopy</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="post-toc-number">23.0.9.</span> <span class="post-toc-text">引用计数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#weak%E6%8C%87%E9%92%88"><span class="post-toc-number">23.0.10.</span> <span class="post-toc-text">weak指针</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ARC"><span class="post-toc-number">23.0.11.</span> <span class="post-toc-text">ARC</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#AutoReleasePool%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0"><span class="post-toc-number">23.0.12.</span> <span class="post-toc-text">AutoReleasePool自动释放池</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="post-toc-number">23.0.13.</span> <span class="post-toc-text">性能优化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8D%A1%E9%A1%BF"><span class="post-toc-number">23.0.13.1.</span> <span class="post-toc-text">卡顿</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%9B%91%E6%8E%A7%E5%8D%A1%E9%A1%BF"><span class="post-toc-number">23.0.13.2.</span> <span class="post-toc-text">监控卡顿</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%94%B5%E9%87%8F"><span class="post-toc-number">23.0.13.3.</span> <span class="post-toc-text">电量</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#LLDB%E8%B0%83%E8%AF%95"><span class="post-toc-number">24.</span> <span class="post-toc-text">LLDB调试</span></a></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 19 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/material-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                iOS笔记梳理
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>yaotao</strong>
        <span>10月 30, 2019</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    

    <!-- Share -->
    
        <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=iOS笔记梳理&url=http://example.com/2019/10/30/%5BiOS%5D%E7%AC%94%E8%AE%B0/index.html&pic=http://example.com/img/favicon.png&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=iOS笔记梳理&url=http://example.com/2019/10/30/%5BiOS%5D%E7%AC%94%E8%AE%B0/index.html&via=yaotao" target="_blank">
            <li class="mdl-menu__item">
                分享到 Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2019/10/30/%5BiOS%5D%E7%AC%94%E8%AE%B0/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://example.com/2019/10/30/%5BiOS%5D%E7%AC%94%E8%AE%B0/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    

    <!-- Share Telegram -->
    
</ul>

    
</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <h2 id="App启动"><a href="#App启动" class="headerlink" title="App启动"></a>App启动</h2><h5 id="1-有storyboard"><a href="#1-有storyboard" class="headerlink" title="1.有storyboard"></a>1.有storyboard</h5><blockquote>
<p>1.main函数；2.创建UIApplication对象；3.根据Info.plist获取Main.storyboard加载；4.创建UIWindow；</p>
</blockquote>
<h5 id="2-无storyboard"><a href="#2-无storyboard" class="headerlink" title="2.无storyboard"></a>2.无storyboard</h5><blockquote>
<p>1.main函数  2.创建UiApplication对象； 3.创建UIApplicationd的delegate对象；4.delegate对象开始处理系统事件，调用代理；5.执行到application：didFinishLaunchingWithOptions；6.创建UIWindow；7.设置RootViewcontroller； 8.显示窗口；</p>
</blockquote>
<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><ul>
<li>区分冷热启动，这里主要讲冷启动</li>
</ul>
<h5 id="1-main函数执行前"><a href="#1-main函数执行前" class="headerlink" title="1.main函数执行前"></a>1.main函数执行前</h5><blockquote>
<p>1.加载可执行文件。（App里的所有.o文件)<br>2.加载动态链接库，进行rebase指针调整和bind符号绑定<br>3.objc的runtime初始化 包括：objc相关Class的注册、category注册、selector唯一性检查等<br>4.初始化。 包括：执行+load()方法、用C++静态构造器 attribute((constructor))修饰的函数的调用、创建C++静态全局变量等</p>
</blockquote>
<blockquote>
<p>简单来说，<br>App启动后，首先，系统内核（Kernel）创建一个进程。其次，加载可执行文件。（可执行文件是指Mach-O格式的文件，也就是App中所有.o文件的集合体）这时，能获取到dyld（dyld是苹果的动态链接器）的路径。<br>然后，加载dyld，主要分为4步：<br>&emsp;1 . load dylibs：这一阶段dyld会分析应用依赖的dylib，找到其mach-o文件，打开和读取这些文件并验证其有效性，接着会找到代码签名注册到内核，最后对dylib的每一个segment调用mmap()。<br>&emsp;2 . rebase/bind：进行rebase指针调整和bind符号绑定。<br>&emsp;3 . ObjC setup：runtime运行时初始化。包括ObjC相关Class的注册、category注册、selector唯一性检查等。<br>&emsp;4 . Initializers：调用每个ObjC类与分类的+load方法，调用attribute((constructor))修饰的函数、创建C++静态全局变量。</p>
</blockquote>
<h5 id="2-main函数执行后"><a href="#2-main函数执行后" class="headerlink" title="2.main函数执行后"></a>2.main函数执行后</h5><blockquote>
<p>这个阶段主要完成的是首屏的一些工作，包括首屏初始化的配置文件读取，列表数据的读取，渲染</p>
</blockquote>
<blockquote>
<p>总的来讲：main函数通知UIApplicationMain()去创建UIApplication(包括：代理，创建主RunLoop)，然后读取plist文件，需不需要storyboard，在didFinish代理回调里设置Window，以及rootController</p>
</blockquote>
<h5 id="3-首屏渲染完成后"><a href="#3-首屏渲染完成后" class="headerlink" title="3.首屏渲染完成后"></a>3.首屏渲染完成后</h5><blockquote>
<p>首屏渲染完成后的阶段，指的是:didFinishLaunchingWithOptions方法作用域内执行首屏渲染后的所有方法执行。即从设置self.window.rootViewController到didFinishLaunchWithOptions方法作用域结束。</p>
</blockquote>
<h4 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h4><ul>
<li>设置EnvionmentVariables ：DYLD_PRINT_STATISTICS 设置为1（用于打印main函数调用之前，启动的各方面耗时）。DYLD_PRINT_STATISTICS_DETAILS ： 可以打印得更详细</li>
<li><blockquote>
<p>&emsp;1.代码内减少使用+load方法,尽量将在+load内执行的内容放到渲染之后，或者使用+initialize()<br>&emsp;2.动态库合并，苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并。数量上，苹果公司最多可以支持6个非系统动态库合并为一个。<br>&emsp;3.优化类、方法、全局变量,减少加载启动后不会去使用的类或方法；少用C++全局变量<br>&emsp;4.优化首屏渲染前的功能初始化,就是尽量不要把初始化放在didFinish</p>
</blockquote>
</li>
</ul>
<h2 id="可执行文件-Mach-o"><a href="#可执行文件-Mach-o" class="headerlink" title="可执行文件(Mach-o)"></a>可执行文件(Mach-o)</h2><ul>
<li>相当于window的exe文件</li>
<li>在ipa包内体积最大那个就是了</li>
<li>可以使用MachoOView分析文件</li>
</ul>
<h2 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h2><blockquote>
<p>&emsp; 库的链接分为静态和动态两种，iOS中直接影响到的就是包体积大小。1. 静态库，在我们开发完成之后会被打包到可执行文件内，包体积就大。2.动态库，比如UIKit系统库，存在于iOS系统内部，不被打包到我们的可执行文件内，只有在包安装到iOS上，启动时候会被dyld（动态链接器）链接起来，app就可以调用系统函数</p>
</blockquote>
<h2 id="Class原理"><a href="#Class原理" class="headerlink" title="Class原理"></a>Class原理</h2><blockquote>
<p>&emsp; Class在iOS中实际上就是指向objc_class结构体的指针 | class、metaclass对象本质都是struct objc_class</p>
</blockquote>
<ul>
<li>1.实例对象（id）：对类对象alloc或者new操作时创建，这个过程中会拷贝实例所属类的成员变量，但并不拷贝类定义的方法。实力对象在内存中存储的信息包括isa指针以及其他成员变量</li>
<li>2.类对象（class）：使用class和object_getClass获取的对象都是类对象；每个类在内存中只有一份；类对象在内存中包括：isa指针、superclass指针，类的属性（property）、类的对象方法信息（instancemethod）、类的协议信息（protocol）、类的成员变量信息（ivar）</li>
<li>3.元类对象（metaclass）：object_getClass([NSObject class])获取到的就是元类对象；每个类的内存有且只有一个meta-class对象;类方法存在于元类对象内；元类对象内包括：isa指针、superclass、类方法</li>
<li>4.[[NSObject class] class] 获取的是类对象不是元类对象</li>
<li><ol start="5">
<li>runtime的class_isMetaClass可以查看是否元类对象</li>
</ol>
</li>
<li>6.实例对象的isa指向类对象，类对象的isa指向元类对象</li>
<li>7.调用实例对象的对象方法时候，通过isa找到类对象，再调用类对象内的对象方法</li>
<li>8.调用类对象的类方法的时候，通过类对象的isa找到元类对象，再调用元类对象内的类方法</li>
<li>9.实例对象没有superclass</li>
<li>10.类对象的superclass指针指向父类的类对象</li>
<li>11.类对象superclass指针最终指向NSObject的类对象</li>
<li>12.实例对象要调用父类的对象方法时，需要使用isa找到自身的类对象，在用类对象的superclass指针找到父类的类对象，从而找到父类的对象方法。（找类方法差不多，就是找metaclass）</li>
<li>13.没有父类，superclas指针为nil</li>
<li>14.64bit开始，利用isa指针查找，需要&amp;ISA_MASK 进行位运算才能计算真实的地址</li>
<li>15.class、metaclass对象本质都是struct objc_class</li>
</ul>
<p><img src="/assets/blogImg/objectClass%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="图片">     </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//1. 弃用的Class指针结构体</span><br><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                               OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">//2.现Class指针结构体</span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    void setData(class_rw_t *newData) &#123;</span><br><span class="line">        bits.setData(newData);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><blockquote>
<ol>
<li>全称 Key-Value Observing(‘键值监听’),可以用于监听某个对象属性值的改变  </li>
<li>KVO时，将被监听的对象isa指针动态修改成新类NSKVONotifying_Person  </li>
<li>同时修改superclass和class两个实现，隐藏了NSKVONotifying_Person的存在，使用object_getClass可以找出来  </li>
<li>通过set方法为属性赋值触发监听，也可以手动触发willcchange和didchange，直接修改成员变量不会触发监听<br><img src="/assets/blogImg/20191030kvo1.png" alt="图片"><br><img src="/assets/blogImg/20191030kvo2.png" alt="图片">     </li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAge:(int)age</span><br><span class="line">&#123;</span><br><span class="line">    _NSSetIntValueAndNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 伪代码</span><br><span class="line">void _NSSetIntValueAndNotify()</span><br><span class="line">&#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">    [super setAge:age];</span><br><span class="line">    [self didChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><blockquote>
<ol>
<li>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性  </li>
</ol>
<ul>
<li>(void)setValue:(id)value forKeyPath:(NSString *)keyPath;</li>
<li>(void)setValue:(id)value forKey:(NSString *)key;</li>
<li>(id)valueForKeyPath:(NSString *)keyPath;</li>
<li>(id)valueForKey:(NSString *)key; </li>
</ul>
</blockquote>
<p><img src="/assets/blogImg/20191030kvc1.png" alt="图片">     </p>
<h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><blockquote>
<ol>
<li>为已经存在的类添加方法、属性，无法添加成员变量；添加属性，只会生成set和get方法  （无法生成成员变量）</li>
<li>Category 中的方法和类中原有方法同名，category 中的方法会覆盖掉类中原有的方法 （最后加载的留下）</li>
<li>使用关联变相给Category添加成员变量 设置：objc_setAssociatedObject，获取：objc_getAssociatedObject(self, &amp;nameKey);      -  分类添加属性</li>
<li>在Objective-C提供的runtime函数中，确实有一个lass_addIvar(),这个函数只能在“构建一个类的过程中”调用。一旦完成类定义，就不能再添加成员变量了。经过编译的类在程序启动后就被runtime加载，没有机会调用addIvar。程序在运行时动态构建的类需要在调用objc_registerClassPair之后才可以被使用，同样没有机会再添加成员变量。  </li>
<li>实例对象在创建的时候就规定了isa指针以及成员变量，也就是实例变量的那块内存布局，如果动态添加了成员变量，就破坏了实例对象内存，这个实例对象就会变成了无效的对象。方法不存在实例对象内！</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//分类的源代码</span><br><span class="line">typedef struct category_t *Category;</span><br><span class="line">struct category_t &#123;</span><br><span class="line">    const char *name;    //category名称</span><br><span class="line">    classref_t cls;     //要拓展的类</span><br><span class="line">    struct method_list_t *instanceMethods; //给类添加的实例方法的列表</span><br><span class="line">    struct method_list_t *classMethods;  //给类添加的类方法的列表</span><br><span class="line">    struct protocol_list_t *protocols;  //给类添加的协议的列表</span><br><span class="line">    struct property_list_t *instanceProperties;  //给类添加的属性的列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="AutoReleasePool"><a href="#AutoReleasePool" class="headerlink" title="AutoReleasePool"></a>AutoReleasePool</h2><ul>
<li>自动释放池 ：一般理解就是自动帮OC对象添加release操作，从而合理管理引用计数</li>
<li>哨兵对象：NSAutoReleasePool 类的 push() 标记 一个哨兵对象 的内存地址，以NSAutoReleasePool成员变量的方式保存。AutoReleasePool代码块里面 创建 的OC对象，都会标记到哨兵对象之后的内存块中。（其实就是类似Array添加对象，然后在释放后把Array里面的所有对象都给释放掉一样），调用 [pool drain] 的时候，实际是调用NSAutoReleasePool 的pop方法，然后把添加在哨兵对象之后的OC对象全部释放  </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//AutoReleasePoolPage的源码大概是这样的流程</span><br><span class="line">NSAutoReleasePool *pool = [[NSAutoReleasePool alloc] init];       ------&gt;  id context = AutoreleasePoolPage.push();</span><br><span class="line">[obj1 autorelease]; -------&gt; getHotPage().add(obj1); 添加到哨兵对象之后</span><br><span class="line">[obj2 autorelease]; -------&gt; getHotPage().add(obj2);</span><br><span class="line">[pool drain]; -------&gt; AutoreleasePoolPage.pop(context);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="load方法"><a href="#load方法" class="headerlink" title="+load方法"></a>+load方法</h2><blockquote>
<ol>
<li>每个类、分类的+load，在程序运行过程中只调用一次  </li>
<li>调用顺序：1先调用类的+load（ 按照编译先后顺序调用，先编译，先调用；调用子类的+load之前会先调用父类的+load），2再调用分类的+load（按照编译先后顺序调用，先编译，先调用）  </li>
<li>+load方法不经过msgSend调用，而是直接使用函数地址  </li>
</ol>
</blockquote>
<blockquote>
<p>+load()与+initialize()两者的区别?<br>+load()方法会在main()函数调用前就调用，而+initialize()是在类第一次使用时才会调用。<br>+load方法的调用优先级: 父类 &gt; 子类 &gt; 分类，并且不会被覆盖，均会调用。<br>+load方法是在main() 函数之前调用，所有的类文件都会加载，包括分类也会加载。<br>+initialize方法的调用优先级：分类 &gt; 子类，父类 &gt; 子类。（父类的分类重写了+initialize方法会覆盖父类的+initialize方法）</p>
</blockquote>
<h2 id="initialize方法"><a href="#initialize方法" class="headerlink" title="+initialize方法"></a>+initialize方法</h2><blockquote>
<ol>
<li>在类第一次接收到消息时调用  </li>
<li>先调用父类的+initialize，再调用子类的+initialize (先初始化父类，再初始化子类，每个类只会初始化1次)  </li>
<li>initialize是通过objc_msgSend进行调用的  </li>
<li>如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次）  </li>
<li>如果分类实现了+initialize，就覆盖类本身的+initialize调用  </li>
</ol>
</blockquote>
<h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><h2 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h2><blockquote>
<ol>
<li>autolayout下系统会在viewDidAppear之前重新根据subView计算contentsize，所以在viewdidiload里面手动设置contentsize会被覆盖；希望在viewdidload下设置contentsize的话需要去掉autolayout选项,或者自己设置subView的constraint，或者在viewdidappear手动设置contentsize</li>
</ol>
</blockquote>
<h2 id="View、UIWindow、CALayer"><a href="#View、UIWindow、CALayer" class="headerlink" title="View、UIWindow、CALayer"></a>View、UIWindow、CALayer</h2><blockquote>
<ol>
<li>View - UIResponder；CALayer - NSObject;  </li>
<li>都是容器，View能响应事件，CALayer不能，UIWindow传递</li>
</ol>
</blockquote>
<h2 id="frame-和-bounds"><a href="#frame-和-bounds" class="headerlink" title="frame 和 bounds"></a>frame 和 bounds</h2><blockquote>
<ol>
<li>frame指的是View在父View中的位置大小，参照物是父View的坐标系  </li>
<li>bounds指的是自身在坐标系中的位置大小，参照物是本身</li>
</ol>
</blockquote>
<h2 id="关联对象ASSOCIATION"><a href="#关联对象ASSOCIATION" class="headerlink" title="关联对象ASSOCIATION"></a>关联对象ASSOCIATION</h2><ul>
<li>我们所说的关联对象的使用环境，或者说面试时候的关联对象，通常以给分类添加属性时候的使用，因为分类无法添加成员变量</li>
</ul>
<blockquote>
<ol>
<li>设置: objc_setAssociatedObject(self, @”name”,name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);   获取: objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);   移除: objc_removeAssociatedObjects(self);</li>
<li>关联对象并不是存储在被关联对象本身内存中  </li>
<li>关联对象存储在全局的统一的一个AssociationsManager中  </li>
<li>策略:</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = 0,  // 指定一个弱引用相关联的对象</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, // 指定相关对象的强引用，非原子性</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,  // 指定相关的对象被复制，非原子性</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = 01401,  // 指定相关对象的强引用，原子性</span><br><span class="line">    OBJC_ASSOCIATION_COPY = 01403     // 指定相关的对象被复制，原子性   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="5">
<li>如果设置关联对象为nil，就相当于是移除关联对象  </li>
<li>weak修饰的属性，在对象销毁时候指针就置空了，但是哈希表内对应的值还在，当我们使用这个指针去释放的时候，这个指针地址已经为空了</li>
</ol>
</blockquote>
<p><img src="/assets/blogImg/AssociationsManagerImage1.png" alt="关联对象原理">     </p>
<h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><blockquote>
<ol>
<li>block本质上也是一个OC对象，它内部也有个isa指针  </li>
<li>block是封装了函数调用以及函数调用环境的OC对象  </li>
<li>为了保证block内部能够正常访问外部的变量，block有个变量捕获机制  </li>
<li>定义block之后修改局部变量的值，在block调用的时候无法生效，局部变量传入block之后，内调用变量是在block内部的变量，所以外部修改局部变量无法生效  </li>
<li>block内部存在一个isa指针，表示这个结构体是一个oc对象  </li>
<li>构造函数中传入的参数都存在了__main_block_impl_0这个结构体中，最后又将这个结构体的指针赋值给了block  </li>
<li>block代码块中的代码被封装成__main_block_func_0函数，FuncPtr则存储着__main_block_func_0函数的地址  </li>
<li>Desc指向__main_block_desc_0结构体对象，其中存储__main_block_impl_0结构体所占用的内存  </li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//clang编译器可以将oc代码装换成c++代码</span><br><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</span><br><span class="line">//oc代码</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        int age = 10;</span><br><span class="line">        void(^block)(int ,int) = ^(int a, int b)&#123;</span><br><span class="line">            NSLog(@&quot;this is block,a = %d,b = %d&quot;,a,b);</span><br><span class="line">            NSLog(@&quot;this is block,age = %d&quot;,age);</span><br><span class="line">        &#125;;</span><br><span class="line">        block(3,5);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义block变量代码</span><br><span class="line">void(*block)(int ,int) = ((void (*)(int, int))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br><span class="line"></span><br><span class="line">//__block_impl结构体</span><br><span class="line">struct __block_impl&#123;</span><br><span class="line">    void *isa;  //&amp;_NSConcreteStackBlockd地址,block就是_NSConcreteStackBlock类型</span><br><span class="line">    int Flags;  //</span><br><span class="line">    int Reserved;</span><br><span class="line">    void *FuncPtr; //block代码块中的代码被封装成__main_block_func_0函数存储在FuncPtr中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行block内部的代码，很明确的能看到我们在使用block内部代码的时候是通过FuncPtr</span><br><span class="line">//这里使用的是__block_imple类型的block，因为__block_impl是__main_block_impl_0的第一个参数，所以起始的内存地址是一致的，可以进行强制类型装换,并且通过这个block找到FuncPtr</span><br><span class="line">((void (*)(__block_impl *, int, int))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block, 3, 5);</span><br><span class="line"></span><br><span class="line">/******8  传入参数  */</span><br><span class="line">//__main_block_func_0存储着我们在block中写入的代码</span><br><span class="line">static void __main_block_func_0（...）&#123;</span><br><span class="line">    int age = _cself-&gt;age</span><br><span class="line">    nslog(...)</span><br><span class="line">    nslog(...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//&amp;__main_block_desc_0_DATA</span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">    size_t reserved     //0</span><br><span class="line">    size_t Blick_size   //传入了 __main_block_impl_0 大小</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123;0,sizefo(struct __main_block_impl_0)&#125;</span><br><span class="line"></span><br><span class="line">//自定义的局部变量，因为在block块中使用带了age这个局部变量，所以将这个age当参数传入了block</span><br><span class="line">age</span><br><span class="line"></span><br><span class="line">/*************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/assets/blogImg/blockimg1.png" alt="_main_block_imp_0结构体"><br><img src="/assets/blogImg/blockimg2.png" alt="block示意图">     </p>
<h2 id="Block捕获"><a href="#Block捕获" class="headerlink" title="Block捕获"></a>Block捕获</h2><ul>
<li><p>Block内部可以正常访问外部变量，有一个捕获的机制</p>
</li>
<li><p>self同样被block捕获，不论对象方法还是类方法都会默认将self作为参数传递给方法内部</p>
</li>
<li><p>即使block中使用的是实例对象的属性，block中捕获的仍然是实例对象，并通过实例对象通过不同的方式去获取使用到的属性（self.name : 捕获self 通过name的get方法）</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4></li>
<li><p>auto变量</p>
<blockquote>
<p>auto自动变量，离开作用域就销毁，通常局部变量前面自动添加auto关键字。<br>自动变量会被捕获到block内部，也就是说block内部会专门新增加一个参数来存储变量的值<br>auto只存在于局部变量中，访问方式为值传递，内存拷贝，深拷贝</p>
</blockquote>
</li>
<li><p>static变量</p>
<blockquote>
<p>static 修饰的变量为指针传递，同样会被block捕获<br>捕获的内部是 int *age 的指针形式</p>
</blockquote>
</li>
<li><p>自动变量和静态变量的区别来自于销毁的机制：自动变量是入栈，函数结束等都可能被销毁；静态变量，内存中有且只有一份，不会被销毁。所以自动变量需要保存值，而静态变量保存指针地址就行</p>
</li>
<li><p>所以外部修改自动变量不影响block内部，修改静态变量就会影响</p>
</li>
</ul>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><ul>
<li>全局变量哪里都能访问，所以__main_block_imp_0没有添加任何变量，不捕获任何变量</li>
<li>局部变量因为跨函数访问所以需要捕获，全局变量在哪里都可以访问 ，所以不用捕获</li>
</ul>
<h2 id="Block类型"><a href="#Block类型" class="headerlink" title="Block类型"></a>Block类型</h2><ul>
<li>ARC环境下会对栈区的block进行一次copy操作，将block提升到堆区</li>
<li>block继承于NSBlock，NSBlock继承于NSObject</li>
<li>block的三种类型：1. <strong>NSGlobalBlock</strong> （ _NSConcreteGlobalBlock ），2.<strong>NSStackBlock</strong> （ _NSConcreteStackBlock ），3.<strong>NSMallocBlock</strong> （ _NSConcreteMallocBlock ）  </li>
<li>NSGlobalBlock ：不访问自动变量，多数情况下使用不到，通常全局变量在哪里都能访问，所以使用函数去完成相应的处理就行了</li>
<li>NSStackBlock：访问自动变量，使用到最多的情况，捕获自动变量进栈</li>
<li>NSMallocBlock：栈区的block在函数作用域结束时候跟着一起销毁，使用copy方式将block提升到堆区，防止内存被回收</li>
</ul>
<p><img src="/assets/blogImg/blockimg3.png" alt="block示意图"><br><em>block在内存中的分配区域</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 验证代码：MRC环境下验证Block到底是进数据段还是堆还是栈</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // Global：没有访问auto变量：__NSGlobalBlock__</span><br><span class="line">        void (^block1)(void) = ^&#123;</span><br><span class="line">            NSLog(@&quot;block1---------&quot;);</span><br><span class="line">        &#125;;   </span><br><span class="line">        // Stack：访问了auto变量： __NSStackBlock__</span><br><span class="line">        int a = 10;</span><br><span class="line">        void (^block2)(void) = ^&#123;</span><br><span class="line">            NSLog(@&quot;block2---------%d&quot;, a);</span><br><span class="line">        &#125;;</span><br><span class="line">        NSLog(@&quot;%@ %@&quot;, [block1 class], [block2 class]);</span><br><span class="line">        // __NSStackBlock__调用copy ： __NSMallocBlock__</span><br><span class="line">        NSLog(@&quot;%@&quot;, [[block2 copy] class]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> // __NSStackBlock__ 调用copy 转化为__NSMallocBlock__ 防止内存作用域过后内存被回收</span><br><span class="line">int age = 10;</span><br><span class="line">block = [^&#123;</span><br><span class="line">    NSLog(@&quot;block---------%d&quot;, age);</span><br><span class="line">&#125; copy];</span><br><span class="line">[block release];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>上述代码验证代码验证各个情况block的内存类型情况，验证结果</em></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>环境</th>
<th>内存区域</th>
</tr>
</thead>
<tbody><tr>
<td><strong>NSGlobalBlock</strong></td>
<td>没有访问auto变量</td>
<td>数据段</td>
</tr>
<tr>
<td><strong>NSStackBlock</strong></td>
<td>访问oauto变量</td>
<td>栈区</td>
</tr>
<tr>
<td><strong>NSMallocBlock</strong></td>
<td>__NSStackBlock__调用copy</td>
<td>堆区</td>
</tr>
</tbody></table>
<p><em>各个类型的Block调用copy对类型的影响</em></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>内存</th>
<th>copy</th>
</tr>
</thead>
<tbody><tr>
<td><strong>NSGlobalBlock</strong></td>
<td>数据段</td>
<td>不改变类型，没反应</td>
</tr>
<tr>
<td><strong>NSStackBlock</strong></td>
<td>栈区</td>
<td>由栈入堆，类型变NSMallocBlock</td>
</tr>
<tr>
<td><strong>NSMallocBlock</strong></td>
<td>堆去</td>
<td>增加引用计数，不改变类型</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//将block赋值给__strong指针时</span><br><span class="line">//block被强指针引用时，RAC也会自动对block进行一次copy操作</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // block内没有访问auto变量</span><br><span class="line">        Block block = ^&#123;</span><br><span class="line">            NSLog(@&quot;block---------&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        NSLog(@&quot;%@&quot;,[block class]);</span><br><span class="line">        int a = 10;</span><br><span class="line">        // block内访问了auto变量，但没有赋值给__strong指针</span><br><span class="line">        NSLog(@&quot;%@&quot;,[^&#123;</span><br><span class="line">            NSLog(@&quot;block1---------%d&quot;, a);</span><br><span class="line">        &#125; class]);</span><br><span class="line">        // block赋值给__strong指针</span><br><span class="line">        Block block2 = ^&#123;</span><br><span class="line">          NSLog(@&quot;block2---------%d&quot;, a);</span><br><span class="line">        &#125;;</span><br><span class="line">        NSLog(@&quot;%@&quot;,[block1 class]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//打印结果:__NSGlobalBlock__;__NSStackBlock__;__NSMallocBlock__</span><br></pre></td></tr></table></figure>


<h2 id="block修饰"><a href="#block修饰" class="headerlink" title="_block修饰"></a>_block修饰</h2><ul>
<li>__block可以用于解决block内部无法修改auto变量值的问题，因为编译器会将_block包装成一个对象（_Block_object_assign），</li>
<li>__block不能修饰全局变量、静态变量（static）  </li>
<li>__block变量从堆上移除会调用__block变量内部的dispose函数，dispose函数内部会调用_Block_object_dispose函数，_Block_object_dispose函数会自动释放指向的对象（release）</li>
<li>当__block变量在栈上时，不会对指向的对象产生强引用<br>_ __block变量被copy到堆时会调用__block变量内部的copy函数,copy函数内部会调用_Block_object_assign函数,_Block_object_assign函数会根据所指向对象的修饰符（__strong、__weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用（注意：这里仅限于ARC时会retain，MRC时不会retain）</li>
</ul>
<p><em>_block修饰变量的实际表现:</em><br><img src="/assets/blogImg/blockimg4.png" alt="block示意图"></p>
<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><ul>
<li>方法替换的实现，本质是类对象内rw_t内 methodlist方法数组内的方法对象的IMP交换掉 </li>
<li>当使用method_exchange进行了函数交换，会清空缓存</li>
<li>替换方法时候需要重新将自生方法调用</li>
</ul>
<p>在项目中的使用：<br>    1.关联对象<br>    2.遍历所有成员变量<br>    3.归档解档<br>    4.交换方法实现<br>    5.利用消息转发修改报错，减少奔溃</p>
<h2 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h2><ul>
<li><p>程序运行时候循环做事情</p>
</li>
<li><p>打个比方：runloop相当于流水线（线程）上的管家，等待我们需要的时候去做相应的操作，没活的时候，流水线改休息的休息（线程休眠），有活的时候就指挥流水线干活，合理分配流水线的工作（合理分配资源）</p>
</li>
<li><p>Runloop和线程的关系<br>  每条线程都有唯一的一个与之对应的runloop对象<br>  Runloop保存在一个全局的字典里面，线程为key，runloop为value<br>  线程刚创建的时候没有runloop对象，Runloop会在第一次获取它时候创建<br>  Runloop会在线程销毁的时候销毁<br>  主线程的Runloop已经自动获取（创建），子线程默认不会开启runloop</p>
</li>
<li><p>同一时间只能使用一个mode，</p>
</li>
<li><p>iOS 中使用了两套API控制Runloop ： NSRunLoop 和 CFRunLoopRef</p>
</li>
<li><p>CFRunLoopRef是开源的，<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/CF/">https://opensource.apple.com/tarballs/CF/</a></p>
</li>
<li><p>使用OC和C两种方式获取同一个Runloop的内存地址不同，原因是NSRunloop包装CFRunloopRef</p>
</li>
<li><p>CFRunLoopModeRef<br>  CFRunLoopModeRef代表RunLoop的运行模式<br>  一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer<br>  RunLoop启动时只能选择其中一个Mode，作为currentMode<br>  如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入<br>  不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响<br>  如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//获取runloop对象</span><br><span class="line"></span><br><span class="line">//OC获取方法</span><br><span class="line">[NSRunLoop currentRunLoop];获取当前线程Runloop</span><br><span class="line">[NSRunLoop mainRunLoop];获取主线程Runloop</span><br><span class="line"></span><br><span class="line">//C语言获取方法</span><br><span class="line">CFRunLoopGetCurrent();获取当前线程</span><br><span class="line">CFRunLoopGetMain();获取主线程</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    </span><br><span class="line">    1、使用子线程执行异步操作</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">    2、使用主线程执行异步操作</span><br><span class="line">    //dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    3、异步，主线程无法同步执行</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1&quot;);</span><br><span class="line">        4、需要注意的是这里：若是在子线程，runloop默认是没开启的，这样一来，performSelector的timer是无法执行的，所以只会打印1和2；如果是在主线程调用，runloop默认能开启就会f打印132</span><br><span class="line">        [self performSelector:@selector(test) withObject:nil afterDelay:.0];</span><br><span class="line">        NSLog(@&quot;3&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)test&#123;</span><br><span class="line">     NSLog(@&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">01、通知Observers：进入Loop</span><br><span class="line">02、通知Observers：即将处理Timers</span><br><span class="line">03、通知Observers：即将处理Sources</span><br><span class="line">04、处理Blocks</span><br><span class="line">05、处理Source0（可能会再次处理Blocks）</span><br><span class="line">06、如果存在Source1，就跳转到第8步</span><br><span class="line">07、通知Observers：开始休眠（等待消息唤醒）</span><br><span class="line">08、通知Observers：结束休眠（被某个消息唤醒）</span><br><span class="line">    01&gt; 处理Timer</span><br><span class="line">    02&gt; 处理GCD Async To Main Queue</span><br><span class="line">    03&gt; 处理Source1</span><br><span class="line">09、处理Blocks</span><br><span class="line">10、根据前面的执行结果，决定如何操作</span><br><span class="line">    01&gt; 回到第02步</span><br><span class="line">    02&gt; 退出Loop</span><br><span class="line">11、通知Observers：退出Loop</span><br><span class="line"></span><br><span class="line">frame #0: 0x0000000102345a7c iOS源码分析项目`-[ViewController touchesBegan:withEvent:](self=0x0000000102902240, _cmd=&quot;touchesBegan:withEvent:&quot;, touches=1 element, event=0x00000002811f43c0) at ViewController.m:23:5</span><br><span class="line">frame #1: 0x00000001b8256b64 UIKitCore`forwardTouchMethod + 328</span><br><span class="line">frame #2: 0x00000001b8256a08 UIKitCore`-[UIResponder touchesBegan:withEvent:] + 60</span><br><span class="line">frame #3: 0x00000001b8264af0 UIKitCore`-[UIWindow _sendTouchesForEvent:] + 1692</span><br><span class="line">frame #4: 0x00000001b82660a8 UIKitCore`-[UIWindow sendEvent:] + 3352</span><br><span class="line">frame #5: 0x00000001b8242ae8 UIKitCore`-[UIApplication sendEvent:] + 336</span><br><span class="line">frame #6: 0x00000001b82ba23c UIKitCore`__dispatchPreprocessedEventFromEventQueue + 5880</span><br><span class="line">frame #7: 0x00000001b82bc798 UIKitCore`__handleEventQueueInternal + 4924</span><br><span class="line">frame #8: 0x00000001b82b560c UIKitCore`__handleHIDEventFetcherDrain + 108</span><br><span class="line">frame #9: 0x00000001b419a7e0 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 24</span><br><span class="line">frame #10: 0x00000001b419a738 CoreFoundation`__CFRunLoopDoSource0 + 80</span><br><span class="line">frame #11: 0x00000001b4199ed0 CoreFoundation`__CFRunLoopDoSources0 + 180</span><br><span class="line">frame #12: 0x00000001b419501c CoreFoundation`__CFRunLoopRun + 1080</span><br><span class="line">frame #13: 0x00000001b41948bc CoreFoundation`CFRunLoopRunSpecific + 464</span><br><span class="line">frame #14: 0x00000001be000328 GraphicsServices`GSEventRunModal + 104</span><br><span class="line">frame #15: 0x00000001b822a6d4 UIKitCore`UIApplicationMain + 1936</span><br><span class="line">frame #16: 0x00000001023459cc iOS源码分析项目`main(argc=1, argv=0x000000016dabf898) at main.m:18:12</span><br><span class="line">frame #17: 0x00000001b401f460 libdyld.dylib`start + 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>关于线程保活问题</li>
<li>1.使用initwithtarget的循环引用</li>
<li>2.生命周期是否跟随控制器</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h5 id="iOS中的多线程方案"><a href="#iOS中的多线程方案" class="headerlink" title="iOS中的多线程方案"></a>iOS中的多线程方案</h5><table>
<thead>
<tr>
<th>技术方案</th>
<th>简介</th>
<th>语言</th>
<th>线程生命周期</th>
<th>使用频率</th>
</tr>
</thead>
<tbody><tr>
<td>pthread</td>
<td>跨平台\可移植，通用的API</td>
<td>C</td>
<td>程序猿管理</td>
<td>几乎不用</td>
</tr>
<tr>
<td>NSThread</td>
<td>使用更加面向对象，使用简单</td>
<td>OC</td>
<td>程序猿管理</td>
<td>偶尔使用</td>
</tr>
<tr>
<td>GCD</td>
<td>充分使用多核处理器，旨在替换NSThread</td>
<td>C</td>
<td>自动管理</td>
<td>经常</td>
</tr>
<tr>
<td>NSOperation</td>
<td>基于GCD，相比GCD更加简单</td>
<td>OC</td>
<td>自动管理</td>
<td>经常</td>
</tr>
</tbody></table>
<h5 id="队列的执行效果"><a href="#队列的执行效果" class="headerlink" title="队列的执行效果"></a>队列的执行效果</h5><table>
<thead>
<tr>
<th>同步 \ 异步</th>
<th>并发队列</th>
<th>手动创建串行队列</th>
<th>主队列</th>
</tr>
</thead>
<tbody><tr>
<td>同步(sync)</td>
<td>没有开启新线程、串行执行</td>
<td>没有开启新线程、串行执行</td>
<td>没有开启新线程、串行执行</td>
</tr>
<tr>
<td>异步(async)</td>
<td>开启新线程、并发执行</td>
<td>开启新线程、串行执行</td>
<td>没有开启新线程、串行执行</td>
</tr>
</tbody></table>
<h5 id="一般知识点"><a href="#一般知识点" class="headerlink" title="一般知识点"></a>一般知识点</h5><blockquote>
<p>1.GCD源码：<a target="_blank" rel="noopener" href="https://github.com/apple/swift-corelibs-libdispatch">https://github.com/apple/swift-corelibs-libdispatch</a><br> 2.注意死锁问题，造成死锁的关键在于：同步执行，并且在当前串行队列中添加任务就会造成死锁，即相互等待<br>3 .[self performSelector]的函数想要在子线程执行，需要启动子线程runloop，睡眠等该函数的执行，不然，在线程的任务一完成，子线程就会退出，这个时候执行performSelector的函数就会报错，提示该线程已经退出<br>4.多线程存在的安全隐患，多条线程同时操作块数据<br>5.cpu在执行多线程的时候就是使用时间片轮转调度算法<br>6.线程同步：不能让多条线程同时占用一份内存<br>7.GCD的常用函数:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//用同步的方式执行任务:</span><br><span class="line">dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)、</span><br><span class="line">//用异步的方式执行任务:</span><br><span class="line">dispatch_async(dispatch_queue_t queue, dispatch_block_t block)</span><br></pre></td></tr></table></figure>


<h5 id="4个术语比较容易混淆：同步、异步、并发、串行"><a href="#4个术语比较容易混淆：同步、异步、并发、串行" class="headerlink" title="4个术语比较容易混淆：同步、异步、并发、串行"></a>4个术语比较容易混淆：同步、异步、并发、串行</h5><blockquote>
<p>1.同步和异步主要影响：能不能开启新的线程<br>2.同步：在当前线程中执行任务，不具备开启新线程的能力<br>3.异步：在新的线程中执行任务，具备开启新线程的能力<br>4.并发和串行主要影响：任务的执行方式<br>5.并发：多个任务并发（同时）执行<br>6.串行：一个任务执行完毕后，再执行下一个任务</p>
</blockquote>
<h5 id="GNUstep"><a href="#GNUstep" class="headerlink" title="GNUstep"></a>GNUstep</h5><p>下载地址：<a target="_blank" rel="noopener" href="http://gnustep.org/resources/downloads.php#core">http://gnustep.org/resources/downloads.php#core</a><br>用于参考Fundation框架</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runmode的原理就是不断的调用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="线程组-可以在开发过程中完成不同任务的执行，同时执行，顺序执行等"><a href="#线程组-可以在开发过程中完成不同任务的执行，同时执行，顺序执行等" class="headerlink" title="线程组 - 可以在开发过程中完成不同任务的执行，同时执行，顺序执行等"></a>线程组 - 可以在开发过程中完成不同任务的执行，同时执行，顺序执行等</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 创建队列组</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    // 创建并发队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;my_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    // 添加异步任务</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            NSLog(@&quot;任务1-%@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            NSLog(@&quot;任务2-%@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">// 等前面的任务执行完毕后，会自动执行这个任务</span><br><span class="line">//    dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">//        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">//            for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">//                NSLog(@&quot;任务3-%@&quot;, [NSThread currentThread]);</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;);</span><br><span class="line">//    &#125;);</span><br><span class="line">    </span><br><span class="line">//    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">//        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">//            NSLog(@&quot;任务3-%@&quot;, [NSThread currentThread]);</span><br><span class="line">//        &#125;</span><br><span class="line">//    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            NSLog(@&quot;任务3-%@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            NSLog(@&quot;任务4-%@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h5 id="OSSpinLock-自旋锁"><a href="#OSSpinLock-自旋锁" class="headerlink" title="OSSpinLock 自旋锁"></a>OSSpinLock 自旋锁</h5><ul>
<li>#import &lt;libkern/OSAtomic.h&gt;</li>
<li>iOS10之后不推荐使用，OSSpinLockUnlock’ is deprecated: first deprecated in iOS 10.0 - Use os_unfair_lock_unlock() from &lt;os/lock.h&gt; </li>
<li>等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</li>
<li>目前已经不再安全，可能会出现优先级反转问题，就是存在优先级比较高的线程在盲等状态， 导致cpu不会给优先级比较低的线程分配时间，这个线程比较低的锁就会卡住，产生类似死锁的情况</li>
<li>如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@property (assign, nonatomic) OSSpinLock lock;</span><br><span class="line">// 初始化</span><br><span class="line">self.lock = OS_SPINLOCK_INIT;</span><br><span class="line">// 加锁</span><br><span class="line">OSSpinLockLock(&amp;_lock);</span><br><span class="line">// 解锁</span><br><span class="line">OSSpinLockUnlock(&amp;_lock);</span><br><span class="line">//尝试加锁</span><br><span class="line">if(OSSpinLockTry(&amp;_lock))&#123;</span><br><span class="line">    </span><br><span class="line">    // 解锁</span><br><span class="line">    OSSpinLockUnlock(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h5><ul>
<li>相比较OSSpinLock，不是盲等状态，而是让线程处于休眠状态，</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">self.lock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line">//加锁</span><br><span class="line">os_unfair_lock_lock(&amp;_ticketLock);</span><br><span class="line">//解锁</span><br><span class="line">os_unfair_lock_unlock(&amp;_ticketLock);</span><br></pre></td></tr></table></figure>

<h5 id="pthread-mutex-互斥锁"><a href="#pthread-mutex-互斥锁" class="headerlink" title="pthread_mutex - 互斥锁"></a>pthread_mutex - 互斥锁</h5><ul>
<li>等待线程会处于睡眠状态</li>
<li> 初始化属性传空表示默认 pthread_mutex_init(mutex, NULL);</li>
<li>关于属性为递归锁 PTHREAD_MUTEX_RECURSIVE：允许同一个线程对一把锁进行重复加锁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#define PTHREAD_MUTEX_NORMAL        0   //默认</span><br><span class="line">#define PTHREAD_MUTEX_ERRORCHECK    1   //检查锁</span><br><span class="line">#define PTHREAD_MUTEX_RECURSIVE     2   //递归锁</span><br><span class="line">#define PTHREAD_MUTEX_DEFAULT        PTHREAD_MUTEX_NORMAL</span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic) pthread_mutex_t moneyMutex;</span><br><span class="line"></span><br><span class="line">- (void)__initMutex:(pthread_mutex_t *)mutex</span><br><span class="line">&#123;</span><br><span class="line">    // 静态初始化</span><br><span class="line">    //        pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">    </span><br><span class="line">//    // 初始化属性</span><br><span class="line">//    pthread_mutexattr_t attr;</span><br><span class="line">//    pthread_mutexattr_init(&amp;attr);</span><br><span class="line">//    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);</span><br><span class="line">//    // 初始化锁</span><br><span class="line">//    pthread_mutex_init(mutex, &amp;attr);</span><br><span class="line">//    // 销毁属性</span><br><span class="line">//    pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">    </span><br><span class="line">    // 初始化属性</span><br><span class="line">//    pthread_mutexattr_t attr;</span><br><span class="line">//    pthread_mutexattr_init(&amp;attr);</span><br><span class="line">//    pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);</span><br><span class="line">    // 初始化锁</span><br><span class="line">    pthread_mutex_init(mutex, NULL);</span><br><span class="line">    // 销毁属性</span><br><span class="line">//    pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//加锁</span><br><span class="line">pthread_mutex_lock(&amp;_ticketMutex);</span><br><span class="line">//解锁</span><br><span class="line">pthread_mutex_unlock(&amp;_ticketMutex);</span><br><span class="line">//销毁</span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="NSConditionLock-条件锁"><a href="#NSConditionLock-条件锁" class="headerlink" title="NSConditionLock - 条件锁"></a>NSConditionLock - 条件锁</h5><ul>
<li>相比较NSCondition条件更加丰富</li>
<li>[self.condition loclWhenCondition:1]; 当条件值为1的时候执行这个加锁，并且执行下去</li>
<li>[self.condition unLoclWhenCondition:2]; 解锁，同时给这个锁一个为2的条件值</li>
</ul>
<h5 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore - 信号量"></a>Semaphore - 信号量</h5><ul>
<li> 控制并发访问的线程数量<br>`<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.如果信号量的值大于0，进来减一</span><br><span class="line">2.如果信号量 = 0，就会休眠等待</span><br><span class="line">3.DISPATCH_TIME_FOREVER：一直等待，等待信号量大于0</span><br><span class="line">4.DISPATCH_TIME_NOW：不等</span><br><span class="line">self.mSemaphore = dispatch_semaphore_create(1);</span><br><span class="line">//信号量等待，并发的信号量数取决于mSemaphore设置的大小</span><br><span class="line">dispatch_semaphore_wait(self.mSemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">//信号量增加</span><br><span class="line">dispatch_semaphore_signal(self.moneySemaphore);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="对比几个锁的区别"><a href="#对比几个锁的区别" class="headerlink" title="对比几个锁的区别"></a>对比几个锁的区别</h5><ul>
<li>自旋锁：wile等待，汇编代码，LLDB调式情况下，会重复调用一段代码，即wile等待</li>
<li>pthread_mutex_lock：不使用的时候必须销毁，可以传入属性分别使用RECURSIVE递归锁或者默认锁</li>
<li>pthread_cond：使用wait等待以及signal信号实现锁的等待和重新开启</li>
<li>NSLock：pthread_mutex 的封装，OC形式的封装，</li>
<li>NSRecursiveLock：pthread_mutex的递归锁的封装，OC的形式使用递归锁</li>
<li>NSConditionLock：相当于包装了pthread_mutex和 pthread_cond 条件，遵守Locking协议，wait和signal配合使用</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h4 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h4><ul>
<li>给属性的set和get方法增加t原子性操作，也就是线程同步，也就是加锁和解锁 slotlock 和unslotlock</li>
<li>耗费性能</li>
<li>无法在持续使用的时候保证线程安全</li>
</ul>
<h4 id="读写安全，IO操作安全"><a href="#读写安全，IO操作安全" class="headerlink" title="读写安全，IO操作安全"></a>读写安全，IO操作安全</h4><ul>
<li>读写锁 pthread_rwlock，自旋锁会等待</li>
<li>dispatch_barrier_async 异步栅栏调用，在使用异步栅栏的时候传入的必须是并发队列，如果传入的是全局的并发或者串行队列的话，效果类似dispatch_async，就不是异步栅栏调用了</li>
</ul>
<h4 id="CADisplaylink-NSTimer"><a href="#CADisplaylink-NSTimer" class="headerlink" title="CADisplaylink NSTimer"></a>CADisplaylink NSTimer</h4><ul>
<li>1.使用target的形式创建的定时器，可能会造成循环引用，使用弱指针无法解决这个定时器的循环引用的问题（不同于block），target还是以参数的形式传入</li>
<li>2.使用block的形式创建的定时器，可以使用弱引用的方法来避免产生循环应用的问题</li>
<li>3.增加中间代理形式也可以避免产生循环应用，其中NSProxy就是用来完成这样的操作，其中使用消息转发的机制可以将函数给被代理方，</li>
<li>4.相比较NSObject做中间代理，完成消息转发的形式，NSProxy不需要到父类寻找方法，而是直接进入消息转发阶段，这样更加的高效</li>
</ul>
<h4 id="GCD定时器"><a href="#GCD定时器" class="headerlink" title="GCD定时器"></a>GCD定时器</h4><ul>
<li>NSTimer 依赖于Runloop，如果runloop的任务过重会导致nstimer不准时</li>
</ul>
<h4 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h4><ul>
<li>从低到高、从上到下：1.保留，2.代码段（TEXT段），3.数据段（DATA）字符串常量，初始化和未初始化的全局变量和静态变量；4.堆区（heap）；5.栈区（stack）；6.内核区</li>
<li>代码段：编译后的代码；</li>
<li>数据段：1.字符串常量，2.已经初始化的全局变量和静态变量，3.未初始化的全局变量和静态变量；</li>
<li>堆：通过alloc，malloc，calloc等动态分配的内存空间，地址从低到高；</li>
<li>栈区：函数调用的开销（局部变量等），分配地址从高到低</li>
</ul>
<h4 id="Tagger-Pointer"><a href="#Tagger-Pointer" class="headerlink" title="Tagger Pointer"></a>Tagger Pointer</h4><ul>
<li>对Tagger Pointer查看引用计数为-1</li>
<li>可以存储NSDate、NSNumber、NSString等</li>
<li>OC对象最小使用16个字节，OC指针8个字节，也就是说在没有Tagger Pointer技术之前，要存储一个NSNumber的值需要使用24个字节，而 int只需要4个字节就行，（减少浪费）</li>
<li>OC对象存储：16个字节内存对齐，所以OC对象指针的最后一位存放0</li>
<li> Tagger Pointer技术将数据直接存放在指针里面</li>
<li>编译器自行处理的</li>
<li>当Tagger Pointer的8个字节存储不下了，就存放在堆区</li>
<li>查找时候不需要像原来的调用，直接到指针内取值，节省了调用的开销</li>
<li>如果指针 p &amp; 1&lt;&lt;63 = 1&lt;&lt;63 的话，这个对象就是一个Tagger Pointer指针，详情查看apple源码的判断是否Tagger Pointer。（mac平台判断最低有效位，iOS判断最高有效位）</li>
<li>总结使用了Tagger Pointer技术，存取都提高了效率</li>
</ul>
<h4 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h4><ul>
<li>引用计数：新创建的OC对象引用计数默认为1</li>
<li>Autorelease 自动释放，需要手动释放的mrc环境下，使用自动释放池，会在合适的时候将自动释放池内的内存进行释放</li>
</ul>
<h4 id="Copy、MutableCopy"><a href="#Copy、MutableCopy" class="headerlink" title="Copy、MutableCopy"></a>Copy、MutableCopy</h4><ul>
<li>原则：拷贝出来的对象修改不影响原对象</li>
<li>1.Copy拷贝出来的都是不可变，MutableCopy拷贝出来的都是可变</li>
<li>2.MutableCopy（不管对可变不可变对象进行拷贝的时候）都是深拷贝，新开辟一块内存存储</li>
<li>3.Copy对可变对象拷贝的时候，深拷贝，会生成一个不可变的对象，新的不可变内存</li>
<li>4.特殊情况：Copy对不可变对象拷贝的时候：浅拷贝，指针拷贝，生成新指针指向同一块内存，且copy引用计数会加一；原因是对不可变对象Copy出来的还是不可变对象，既然是不可变对象不能修改，就不生成新的对象浪费内存</li>
<li>5.属性中使用copy，表示就是将来新传进来的对象就是进行一次copy操作，所以属性只要用得copy关键字，就不要使用可变对象，后期使用可变的函数会报错，方法不存在</li>
<li>6.实现copy协议可以使对象可以copy</li>
</ul>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><ul>
<li>oc源码：NSObject.mm内 ratinCount函数，先判断isa是否64位新指针，再判断是否存在SideTqbles中的RefcountMap(哈希表)</li>
<li>对象的引用计数存放在对象isa指针结构体得最后一个数（19位），如果19位不够存储，则将改引用计数存放在isa指针内的一个SideTqbles中（散列表结构）</li>
<li>retain加一，release减一</li>
<li>对象引用计数减为0时候msgsend 发送dealloc消息销毁对象</li>
</ul>
<h4 id="weak指针"><a href="#weak指针" class="headerlink" title="weak指针"></a>weak指针</h4><ul>
<li>isa指针内的SideTable存在一个表，用于存放weak指针的weak_table_t（哈希表）中</li>
<li>在对象销毁时会调用clearDeallocating函数找到存放弱指针的哈希表，清除弱引用</li>
</ul>
<h4 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h4><ul>
<li>LLVM编译器会在合适得地方自动生成 release，autorelease代码</li>
<li>Runtime处理弱引用等操作</li>
<li>编译器对局部对象在当前函数最后添加release，对象会在函数执行完毕时候就释放</li>
</ul>
<h4 id="AutoReleasePool自动释放池"><a href="#AutoReleasePool自动释放池" class="headerlink" title="AutoReleasePool自动释放池"></a>AutoReleasePool自动释放池</h4><ul>
<li>存在构造函数和析构函数，构造函数会调用push，析构函数会调用pop</li>
<li>在释放池内得函数相当于夹在了释放池的push和pop两个函数之间</li>
<li>释放池会在push()的时候入栈一个POOL_BOUNDAY（边界），在pop()结束的时候将这个边界的地址值传入，从最后开始Release，直到遇到这个边界表示释放完毕</li>
<li>每个@AutoReleasePool回调一次push，每次push都会加一个边界</li>
<li> 查看自动释放池情况的函数（不开源的）： 1.声明 extern void _objc_autoreleasePoolPrint(void); 2. 使用 _objc_autoreleasePoolPrint();</li>
<li>释放时机：执行release是由runloop决定的，释放池会在runloop休眠时执行pop完成release操作</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><h5 id="卡顿"><a href="#卡顿" class="headerlink" title="卡顿"></a>卡顿</h5><ul>
<li>将cpu和gpu处理的时间控制在16毫秒内，保证60fps的帧频</li>
<li>尽量使用轻量级对象</li>
<li>不要频繁使用View的相关属性，尽量避免不必要的修改</li>
<li>提前计算好布局，在需要时一次性修改</li>
<li>Autolayout会比直接设置frame更消耗cpu资源</li>
<li>控制线程并发数量</li>
<li>图片得size最好跟UIImageView的大小保持一致</li>
<li>耗时操作放入子线程（文本绘制，图片解码在子线程解码）</li>
<li>减少视图层次</li>
<li>减少透明的View</li>
<li>避免离屏渲染（光栅化：layer.shouldRasterize = yes, 遮罩，圆角，阴影）</li>
</ul>
<h5 id="监控卡顿"><a href="#监控卡顿" class="headerlink" title="监控卡顿"></a>监控卡顿</h5><ul>
<li>检测runloop 处理source的时间达到监控卡顿的效果</li>
</ul>
<h5 id="电量"><a href="#电量" class="headerlink" title="电量"></a>电量</h5><ul>
<li>降低CPU、GPU的消耗</li>
<li>尽量少用定时器</li>
<li>优化文件操作</li>
<li>iOS提供了基于GCD得一部操作API，dispatch_io，优化了磁盘访问</li>
<li>压缩网络数据 </li>
<li>尽量避免实时定位</li>
<li>只需要一次获取位置可以使用requestLocation，该函数会调用一次定位获取用户位置信息，用完之后就对定位的硬件进行断电</li>
<li>如果实时要求较高的，可以选择合适的定位精度，精度越高调用频率越高，耗电就越快</li>
</ul>
<h2 id="LLDB调试"><a href="#LLDB调试" class="headerlink" title="LLDB调试"></a>LLDB调试</h2>
        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2019/11/05/%5B%E6%97%A5%E5%B8%B8%5D%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            新篇
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2019/10/15/%5B%E5%B0%8F%E7%A8%8B%E5%BA%8F%5D%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%82%B9/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="yaotao's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        1007881775@qq.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="mailto:1007881775@qq.com" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2021/09/">九月 2021<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/05/">五月 2020<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/02/">二月 2020<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/11/">十一月 2019<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/10/">十月 2019<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/09/">九月 2019<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/07/">七月 2019<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/06/">六月 2019<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/05/">五月 2019<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/04/">四月 2019<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/03/">三月 2019<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/08/">八月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/07/">七月 2018<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/06/">六月 2018<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/05/">五月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/03/">三月 2018<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2018/01/">一月 2018<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/12/">十二月 2017<span class="sidebar_archives-count">2</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/08/">八月 2017<span class="sidebar_archives-count">3</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    

    <!-- Pages  -->
    
        <li>
            <a href="/about" title="关于我">
                
                    <i class="material-icons sidebar-material-icons">person</i>
                
                关于我
            </a>
        </li>
        
    
        <li>
            <a href="/pdf" title="书籍">
                
                    <i class="material-icons sidebar-material-icons">book</i>
                
                书籍
            </a>
        </li>
        
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            主题 - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-facebook">
                <span class="visuallyhidden">Facebook</span>
            </button><!--
     --></a>
    

    <!-- Google + -->
    

    <!-- Weibo -->
    
        <a href="https://weibo.com/3852766965" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-weibo">
                <span class="visuallyhidden">Weibo</span>
            </button><!--
     --></a>
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/yaotao1995" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-github">
                <span class="visuallyhidden">Github</span>
            </button><!--
     --></a>
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    
        <a href="https://www.zhihu.com/people/yaotao-9" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-zhihu">
                <span class="visuallyhidden">Zhihu</span>
            </button><!--
     --></a>
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    

    <!-- V2EX -->
    

    <!-- Segmentfault -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;<span year></span>&nbsp;YaoTao'sBlog
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?Bn9UzEm8RrBSxqyZB0zPjA==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('
<link rel="stylesheet" href="/css/uc.css">
');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    var copyrightNow = new Date().getFullYear();
    var textContent = document.querySelector('span[year]')

    copyrightSince = 0000;
    if (copyrightSince === copyrightNow||copyrightSince === 0000) {
        textContent.textContent = copyrightNow
    } else {
        textContent.textContent = copyrightSince + ' - ' + copyrightNow
    }

    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.6 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
